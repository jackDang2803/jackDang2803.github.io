<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Opposite Scrolling (First/Last 100vw, Vertical Alignment)</title>
  <style>
    /* Basic reset & full viewport height */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* We only scroll within the .container elements */
      font-family: sans-serif;
    }

    /* Each container is half the window's height (50vh). */
    .container {
      width: 100%;
      height: 50vh;
      overflow-x: scroll;    /* Horizontal scrolling */
      overflow-y: hidden;    /* Hide vertical scrollbar */
      white-space: nowrap;   /* Keep child "sections" side by side horizontally */

      /* Hide scrollbars visually across major browsers */
      -ms-overflow-style: none; /* IE/Edge */
      scrollbar-width: none;    /* Firefox */
    }
    .container::-webkit-scrollbar {
      display: none;           /* Chrome/Safari/Opera */
    }

    /* Each .content is 400vw wide, containing 4 "section" blocks of 100vw each. */
    .content {
      width: 400vw;
      height: 100%;
      display: flex;     /* So our .section elements line up horizontally */
    }

    /* 
      Each .section is exactly 100vw wide and does not shrink below that.
      We use flex to center text horizontally. 
      We'll handle vertical alignment separately for each container (top/bottom).
    */
    .section {
      width: 100vw;
      flex-shrink: 0;       
      display: flex;        
      justify-content: center;  /* horizontally center */
      padding: 1rem;
      border: 1px solid rgba(0,0,0,0.1);
    }

    /*
      TOP container’s sections → align text at bottom (flex-end).
      BOTTOM container’s sections → align text at top (flex-start).
      This sets vertical alignment differently for the top vs. bottom halves.
    */
    .top .section {
      align-items: flex-end; /* vertically bottom */
    }
    .bottom .section {
      align-items: flex-start; /* vertically top */
    }

    /* Just some background colors to differentiate each 100vw section */
    .section:nth-child(1) { background: #cce5ff; }  /* leftmost 100vw */
    .section:nth-child(2) { background: #ffe5cc; }
    .section:nth-child(3) { background: #e5ffcc; }
    .section:nth-child(4) { background: #ffe5f2; }  /* rightmost 100vw */

    /* Text style inside each section */
    .section span {
      font-size: 2rem;
      color: #333;
      text-align: center;
      line-height: 1.4;
    }
  </style>
</head>
<body>

  <!-- TOP half container (scrolls left→right) -->
  <div class="container top">
    <div class="content">
      <!-- 4 horizontal sections, each 100vw wide -->
      <div class="section">
        <!-- TOP text in the first 100vw, horizontally centered, vertically at the bottom -->
        <span>
            <h1>Heading 1</h1>
          1 person, 2 focuses<br>
          FOCUS 1
        </span>
      </div>
      <div class="section"></div>
      <div class="section"></div>
      <div class="section"></div>
    </div>
  </div>

  <!-- BOTTOM half container (scrolls right→left) -->
  <div class="container bottom">
    <div class="content">
      <div class="section"></div>
      <div class="section"></div>
      <div class="section"></div>
      <div class="section">
        <!-- BOTTOM text in the last 100vw, horizontally centered, vertically at the top -->
        <span>
          FOCUS 2<br>
          (Centered horizontally, aligned at container top)<br>
          Last 100vw slice
        </span>
      </div>
    </div>
  </div>

  <script>
    const topContainer = document.querySelector('.top');
    const bottomContainer = document.querySelector('.bottom');

    // Prevent infinite loop while syncing
    let isSyncing = false;

    /** 
     * Opposite-scrolling sync: 
     * when one container scrolls, the other = maxScroll - scrollLeft
     */
    function handleScroll(e) {
      if (isSyncing) return;
      isSyncing = true;

      if (e.target === topContainer) {
        const maxScrollBottom = bottomContainer.scrollWidth - bottomContainer.clientWidth;
        bottomContainer.scrollLeft = maxScrollBottom - topContainer.scrollLeft;
      } else {
        const maxScrollTop = topContainer.scrollWidth - topContainer.clientWidth;
        topContainer.scrollLeft = maxScrollTop - bottomContainer.scrollLeft;
      }

      isSyncing = false;
    }

    /**
     * Convert vertical wheel movement into horizontal scroll for the TOP container:
     * Scrolling down => left→right => scrollLeft += deltaY
     */
    function handleWheelTop(e) {
      e.preventDefault(); // stop normal vertical scroll
      const old = topContainer.scrollLeft;
      topContainer.scrollLeft += e.deltaY;
      if (topContainer.scrollLeft !== old) handleScroll({ target: topContainer });
    }

    /**
     * Convert vertical wheel movement into horizontal scroll for the BOTTOM container:
     * Scrolling down => right→left => scrollLeft -= deltaY
     */
    function handleWheelBottom(e) {
      e.preventDefault();
      const old = bottomContainer.scrollLeft;
      bottomContainer.scrollLeft -= e.deltaY;
      if (bottomContainer.scrollLeft !== old) handleScroll({ target: bottomContainer });
    }

    // Listen for "scroll" events (e.g. trackpad horizontal swipes)
    topContainer.addEventListener('scroll', handleScroll);
    bottomContainer.addEventListener('scroll', handleScroll);

    // Listen for wheel events
    topContainer.addEventListener('wheel', handleWheelTop, { passive: false });
    bottomContainer.addEventListener('wheel', handleWheelBottom, { passive: false });

    // On load:
    //  - TOP container sees its first 100vw => scrollLeft = 0
    //  - BOTTOM container sees its last 100vw => scrollLeft = 300vw
    window.addEventListener('load', () => {
      // Top at far left
      topContainer.scrollLeft = 0;

      // Bottom at far right
      const maxScroll = bottomContainer.scrollWidth - bottomContainer.clientWidth; // ~300vw in px
      bottomContainer.scrollLeft = maxScroll;
    });
  </script>
</body>
</html>
