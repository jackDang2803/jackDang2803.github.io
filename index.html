<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Opposite Scrolling - Fixed Offset</title>
  <style>
    /* -----------------------------
       1) Lock the page from scrolling
       so we only scroll inside .top & .bottom
    ------------------------------ */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* no page scrollbars */
      font-family: sans-serif;
    }

    /* -----------------------------
       2) Each container is half the viewport
       height (50vh) with horizontal scrolling.
    ------------------------------ */
    .container {
      width: 100%;
      height: 50vh;
      overflow-x: scroll;   /* horizontal scroll */
      overflow-y: hidden;   /* hide vertical scroll */
      white-space: nowrap;  /* keep child sections in one horizontal row */

      /* Hide scrollbars visually */
      -ms-overflow-style: none; /* IE/Edge */
      scrollbar-width: none;    /* Firefox */
    }
    .container::-webkit-scrollbar {
      display: none;           /* Chrome/Safari/Opera */
    }

    /* The content row is 2 "slides" wide => 2 * 100vw = 200vw. */
    .content {
      width: 200vw; 
      height: 100%;
      display: flex;    /* put .section blocks side by side */
    }

    /* Each section is 100vw wide, no shrinking. */
    .section {
      width: 100vw;
      flex-shrink: 0;
      display: flex;
      /* Center text horizontally & vertically */
      align-items: center; 
      justify-content: center;
      border: 1px solid rgba(0,0,0,0.1);
    }
    
    /*
      TOP container’s sections → align text at bottom (flex-end).
      BOTTOM container’s sections → align text at top (flex-start).
      This sets vertical alignment differently for the top vs. bottom halves.
    */
    .top .section {
      align-items: flex-end; /* vertically bottom */
    }
    .bottom .section {
      align-items: flex-start; /* vertically top */
    }

    /* Different backgrounds for each 100vw "slide" */
    .section:nth-child(1) { background: #cce5ff; }
    .section:nth-child(2) { background: #ffe5cc; }

    /* Slightly bigger text inside each section */
    .section span {
      font-size: 2rem;
      color: #333;
      text-align: center;
      line-height: 1.4;
    }
  </style>
</head>
<body>

  <!-- TOP half: scroll left → right -->
  <div class="container top">
    <div class="content">
      <!-- 1st slide (left) -->
      <div class="section">
        <span>
          <h1>Heading 1234 (Top #1)</h1>
          1 person, 2 focuses<br>
          FOCUS 1
        </span>
      </div>
      <!-- 2nd slide (right) -->
      <div class="section">
        <span>
          <h1>Heading 5678 (Top #2)</h1>
          Another text block<br>
          Something else here
        </span>
      </div>
    </div>
  </div>

  <!-- BOTTOM half: scroll right → left -->
  <div class="container bottom">
    <div class="content">
      <!-- 1st slide (left) -->
      <div class="section">
        <span>
          <h1>Focus 2 (Bottom #1)</h1>
          Left slide
        </span>
      </div>
      <!-- 2nd slide (right) -->
      <div class="section">
        <span>
          <h1>Focus 2 (Bottom #2)</h1>
          Right slide
        </span>
      </div>
    </div>
  </div>

  <script>
    const topContainer = document.querySelector('.top');
    const bottomContainer = document.querySelector('.bottom');

    let isSyncing = false;

    /**
     * Sync scroll in opposite directions:
     *   topContainer.scrollLeft = x
     *   bottomContainer.scrollLeft = (maxScrollBottom - x)
     */
    function handleScroll(e) {
      if (isSyncing) return;
      isSyncing = true;

      if (e.target === topContainer) {
        const maxScrollBottom = bottomContainer.scrollWidth - bottomContainer.clientWidth;
        bottomContainer.scrollLeft = maxScrollBottom - topContainer.scrollLeft;
      } else {
        const maxScrollTop = topContainer.scrollWidth - topContainer.clientWidth;
        topContainer.scrollLeft = maxScrollTop - bottomContainer.scrollLeft;
      }

      isSyncing = false;
    }

    /**
     * Convert vertical wheel events into horizontal scroll.
     * For the top container: scrolling "down" => scrollLeft += deltaY
     */
    function handleWheelTop(e) {
      e.preventDefault();
      const old = topContainer.scrollLeft;
      topContainer.scrollLeft += e.deltaY;
      if (topContainer.scrollLeft !== old) {
        handleScroll({ target: topContainer });
      }
    }

    /**
     * For the bottom container: scrolling "down" => scrollLeft -= deltaY
     */
    function handleWheelBottom(e) {
      e.preventDefault();
      const old = bottomContainer.scrollLeft;
      bottomContainer.scrollLeft -= e.deltaY;
      if (bottomContainer.scrollLeft !== old) {
        handleScroll({ target: bottomContainer });
      }
    }

    // Listen to scroll & wheel events
    topContainer.addEventListener('scroll', handleScroll);
    bottomContainer.addEventListener('scroll', handleScroll);

    topContainer.addEventListener('wheel', handleWheelTop, { passive: false });
    bottomContainer.addEventListener('wheel', handleWheelBottom, { passive: false });

    // On load, set top to left edge (0), bottom to right edge (maxScroll)
    window.addEventListener('load', () => {
      topContainer.scrollLeft = 0;
      const maxScroll = bottomContainer.scrollWidth - bottomContainer.clientWidth;
      bottomContainer.scrollLeft = maxScroll;
    });
  </script>
</body>
</html>
